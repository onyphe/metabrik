Prio:
-> rename Plasy to Metabricky
-> create catageories (Brick::Core::Shell, Brick::Core::Global)
-> Brickify Context and Shell

Rationales:
-> Tired of writing again and again some Perl scripts to do same things (where did I put this one?)
-> Tired of using different programs with different syntax
-> Tired of being lost when using Windows

Metabricky:
-> takes the best from MetaSploit CLI, Scapy ideas, and UNIX Shells.
-> Bind them in the darkness.

Metabricky - knowledge is in your head, detail is in the code
Metabricky - There is a Brick for that.
> Brain has knowledge, code has details.

Move everything to a Brick. Even ls, save, ..., cd ...
-> The software in itself is built using Bricks ...

Name:
MetaBricks?
MetaBricko?
MecaBrick?
> metabricky/meby
MetaBricko?
MetaScapy? MSP/MSY
Bricko
Bricko Depo

Design rules:
1. Only shell commands can overwrite $_
2. Must be quick and easy to develop bricks
3. Must be quick and easy to USE bricks
4. Do simple functions
5. One or two args at most for a brick command, other stuff in `set' attributes
6. Everything is a brick, like everything is a file in UNIX
7. Performance is not the goal
8. Return USEFUL things from brick EVERY commands
9. Reuse CPAN modules as much as possible

Developer rules:
- in Context::call or ::do, die() will be catched.
=> Bricks do not need access to $log.

Usage rules:
1. Three kind of command lines:
- Perl line
- Metabricky shell line
- External command

Vocabulary:
- The Shell has builtins (load, set, run)
- The Shell loads Bricks
- A Brick has Commands (not methods)
- A Brick has Attributes (you can set using `set' builtin)
- A Brick Command may have Arguments
- A Brick is attached to a Category
- Brickification: process of turning a process/software into a Meby Brick
=> Rename to use that in all code

Split Metabricky into:
- Metabricky::Brick::Shell for Term::Shell stuff

Bricks TODO
- Heartbleed
- Zmap
- SSL Capable NetCat

Rename bricks methods to use run_. Modify Metabricky::Brick to work like Term::Shell to auto discover methods.

use page() and pager_internal() from Term::Shell

Wwwutil:
-> Interrogates Hurricane Electric stuff: http://bgp.he.net/ip/130.193.27.21

staticperl, standalone Perl with libc:
http://search.cpan.org/~mlehmann/App-Staticperl-1.43/

How to launch a process in foreground and move it to background:
IPC::Run
IPC::Run IPC::ChildSafe Proc::Simple Proc::Reliable Proc::Fork
IO::Pipe
IPC::Run::Proc
IPC::Exe
Proc::SafeExec
Forks::Super
Spawn::Safe

shell functions:
export VAR value => $ENV{VAR} = value
unset VAR => undef $ENV{VAR}
=> completion on ENV variables
set $? and $! to indicate error and print error string

Name:
-> Metabricky (formerly Plashy: Perl Awesome|Audit|Attack|All-in-one Shell (Yeaaahh))
-> y: Why the Y? Yeaaaah

write/save: writes $_ content to a file (set out 'file.txt')
set global input $_  # default
set global ouput $_  # default
=> input and ouput may also be bricks (future work)

Proc::Simple:
=> launch cmd as background jobs (&)
=> launch system commands as background jobs

Bricks API:
-> require_arg() to check for a method invocation
-> require_called_first() or require_commands() to check for a previous method to be called first
-> require_modules() to eval() required modules for bricks.

Makes use of modules:
File::Spec (path manipulation)
File::Dirname
ExtUtils::Command (shell builtins)
Env::PS1
Text::Balanced
Proc::SafePipe (http://search.cpan.org/~rosch/Proc-SafePipe-0.01/SafePipe.pm)
File::Tools
=> ls, cd, cat, df, ...
Term::ShellKit::Commands
=> reload, load, show methods/functions of a module

Take stuff from pirl:
pirl: http://cpansearch.perl.org/src/RSAVAGE/Shell-Perl-0.0023/lib/Shell/Perl.pm
ipirl: https://code.google.com/p/iperl/

Gather available methods/functions:
use Metabricky::Brick::Core::Global;

--8<--
my $pkg = "Metabricky::Brick::Core::Global";
no strict 'refs';
my @r = keys %{ $pkg . "::" };
use Data::Dumper;
print Dumper(\@r);
--8<--
