### TODO

### 1.00

-> rename: inited() to init_done?
=> add: _set_defa..._done, _check_require..._done

-> core::shell:
=> for each run_* write a *() method. Ex: run_run() => run(), so help_run will work

-> pod.

-> remove: run_pl() integrate into catch_run() instead.

-> add: check_properties(), require_binaries()

Changer : par | (path dans file::find)
Separateur officiel: |
=> No; use ARRAYREF directly

-> merge ext::shell to core::shell
-> review: ext::shell: $used to use is_used and like
-> make core::shell Brik to depend on the fewest module as possible

-> getopt for bin/metabrik

-> integrate cpanm into Metabrik
=> brik: module::install, perl::install?

-> remote::ssh2, check for exit_status when exec()

### LOGO

-> chose ASCII art:
=> http://www.retrojunkie.com/asciiart/animals/animals.htm
=> Beaver?
=> http://www.asciiworld.com/-Police,150-.html
=> http://patorjk.com/software/taag/#p=testall&f=Graffiti&t=MetabriK
=> Ornitorinc

### BRIKS

-> new: file::xml
=> use file::read and encoding::xml

-> new: encoding::csv encode/decode with Attributes separator, format like CSV::Hashify

-> rename: numbers::iana => iana::countrycodes
-> new: iana::servicenames
=> http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml

-> network::mitm
=> route()
=> dns()
=> arp()
=> ssl()
=> smb() (metasploit auxiliary/server/capture/smb)

-> sslsplit
=> http://www.roe.ch/SSLsplit
=> http://blog.philippheckel.com/2013/08/04/use-sslsplit-to-transparently-sniff-tls-ssl-connections/

-> certificate::pki or x509::pki
=> use GomorCA scripts.

-> ssl checks
=> http://www.exploresecurity.com/wp-content/uploads/custom/SSL_manual_cheatsheet.html

-> dns tool
=> https://blog.skullsecurity.org/2010/call-for-testers-nbtool-0-05-and-dnscat-0-05
=> https://github.com/iagox86/dnscat2

-> system::os:
=> add distribution Command (Ubuntu)
=> add distribution_version Command
=> add distribution_codename Command
=> add distribution_description Command

-> www::cewl => to gather keywords for brute-force attacks

-> DESIGN: shall Commands take no argument?
=> No.

-> tags: support : to specify multiple tags
=> search tag to display also available briks
=> search string: uniformise like search tag

-> Brik API: add newed() Attribute to avoid recreating accessors or other stuff
=> Define our own TYPES (SCALAR, HASH, ARRAY, URL, NUMBER, ...)
-> core::context: check_properties() for validity on use(), do it one time, sets _checked
=> also check if some commands will overwrite base class commands

-> shell::builtins

-> system::identify
=> returns Linux/Ubuntu/...
=> or update system::os to fetch distrib information
=> new: ubuntu::os, ubuntu::package, and system::os uses ubuntu::os, same for system::package

### Future (or not):
-> update() function to autoupdate

-> new: use_if_not_used, run_if_used, set_if_used, get_if_used

Briks API: See remote::ssh2
-> require_arg() to check for a method invocation
-> require_called_first() or require_commands() to check for a previous method to be called first

Wwwutil:
-> Interrogates Hurricane Electric stuff: http://bgp.he.net/ip/130.193.27.21


API:
Step 1:
- use
=> new() + preinit()
- set
- get
- run
=> init() (first time only) + run()
- DESTROY
=> fini()

### BrikS TODO
- Heartbleed
- Zmap
- SSL Capable NetCat
- /usr/ports/net/GeoIP
- system::os: version, name, ...
- string::grep
- string::less
- file::grep
- file::less


### DOC/PRES

Name:
-> Metabrik (formerly Plashy: Perl Awesome|Audit|Attack|All-in-one Shell (Yeaaahh))
-> y: Why the Y? Yeaaaah

Rationales:
-> Tired of writing again and again some Perl scripts to do same things (where did I put this one?)
-> Tired of using different programs with different syntax
-> Tired of being lost when using Windows

-> Tired of trying to remember again and again what is the syntax for this specific command, or worst, trying to remember what is the command for doing this or this
=> example : configuring wifi card in monitor mode

Metabrik:
-> takes the best from MetaSploit CLI, Scapy ideas, and UNIX Shells.
-> Bind them in the darkness.

It is like Minecraft. The more Brik you write, the more complex project you can do.

Metabrik - knowledge is in your head, detail is in the code
Metabrik - There is a Brik for that.
> Brain has knowledge, code has details.

Move everything to a Brik. Even ls, save, ..., cd ...
-> The software in itself is built using Briks ...

Name:
MetaBriks?
MetaBriko?
MecaBrik?
> metaBriky/meby
MetaBriko?
MetaScapy? MSP/MSY
Briko
Briko Depo

Tags
TODO > experimental > unstable > stable
expe: everything can change (name, API)
unstable: API may change
stable: used extensively, can be enriched

Design rules:
1. Only shell `run' and `get' commands can overwrite $_
=> all shell `run' and `get' commands writes $_, $? and $@ (including !, which is an alias)
2. Must be quick and easy to develop Briks
3. Must be quick and easy to USE Briks
4. Do simple functions
5. One or two args at most for a Brik command, other stuff in `set' attributes
6. Everything is a Brik, like everything is a file in UNIX
7. Performance is not the goal
8. Return USEFUL things from Brik EVERY commands
9. Reuse CPAN modules as much as possible
10. Run command once, analyze at will
11. Commands should be non-blocking
12. Commands to return only base scalars (scalar, hashref, arrayref)

-> Within meta Shell, Briks do not print anything by default, except if core::shell echo is set to true.
=> $_ is written with the result.

Developer rules:
- in Context::call or ::do, die() will be catched.
=> Briks do not need access to $log.

Usage rules:
1. Three kind of command lines:
- Perl line
- Metabrik shell line
- External command

Vocabulary:
- The Shell has builtins (use, set, get, run)
- The Shell uses Briks
- Meta is the Metabrik shell
- You enter Words on shell CLI (run core::context get, 3 words)
- meta is the Metabrik shell
- A Brik has Commands (not methods)
- A Brik has Attributes (you can set using `set' builtin)
- A Brik Command may have Arguments
- A Brik is attached to a Category
- A Brik has a Category
- A Brik may have a Repository
- Brikification: process of turning a process/software into a Meta Brik
=> Rename to use that in all code
- Meta shell can execute Code (Perl code)


Doc:
- core::context Brik autouses core::global Brik
-> core::* Briks are always used and available in ->Briks->{$Brik}
- declare_* returns an ARRAYREF
- require_* returns an HASHREF with ARRAYREF values

### FURTURE WORK

staticperl, standalone Perl with libc:
http://search.cpan.org/~mlehmann/App-Staticperl-1.43/

Take stuff from pirl:
pirl: http://cpansearch.perl.org/src/RSAVAGE/Shell-Perl-0.0023/lib/Shell/Perl.pm
ipirl: https://code.google.com/p/iperl/

How to launch a process in foreground and move it to background:
IPC::Run
IPC::Run IPC::ChildSafe Proc::Simple Proc::Reliable Proc::Fork
IO::Pipe
IPC::Run::Proc
IPC::Exe
Proc::SafeExec
Forks::Super
Spawn::Safe

shell functions:
export VAR value => $ENV{VAR} = value
unset VAR => undef $ENV{VAR}
=> completion on ENV variables
set $? and $! to indicate error and print error string

write/save: writes $_ content to a file (set out 'file.txt')
set global input $_  # default
set global ouput $_  # default
=> input and ouput may also be Briks (future work)

Proc::Simple:
=> launch cmd as background jobs (&)
=> launch system commands as background jobs

Makes use of modules:
File::Spec (path manipulation)
File::Dirname
ExtUtils::Command (shell builtins)
Env::PS1
Text::Balanced
Proc::SafePipe (http://search.cpan.org/~rosch/Proc-SafePipe-0.01/SafePipe.pm)
File::Tools
=> ls, cd, cat, df, ...
Term::ShellKit::Commands
=> reuse, use, show methods/functions of a module

Outils similaires:
-> pwntools
-> scapy?
-> metasploit
