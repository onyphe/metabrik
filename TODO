### TODO

Prio:
-> alias support. example: alias ls "!ls -lF"

-> update: use help() to fetch canable Attributes and Commands

-> new: possibility to loop on run() or get() or set() in a multiline code

-> update: when calling a script from meby binary, do not process .mebyrc by default

-> update: remove do() and use call() everywhere

-> bug: script cannot handle multiline with \ char

-> bug: ps_lookup_var* cannot handle \n char (multiline does not work), may be a limitation of Term::Shell?

-> rename: file::slurp => file::read
=> move $_->{a} stuff to string::parse?
=> rename file Attribute to input (use global input)

-> ext::log: to be removed. Only Core::Log should remain. Other bricks can inherite from there.

-> update: bricks using bricks should call is_loaded and die if not i/o using from Perl itself
=> if not loaded, feature is disabled
=> example: database::keystore

-> bug: cd <completion> does not work because of comp_cd()
=> shell::history, shell::builtins

-> bug: get should not set $_!!!! it is the role of run() only.

-> bug: remote::tcpdump: can Command and Attribute does not work when subclassing (see obssi::pandore)

-> bug: on doing multiline Perl code, it overwrites $_

-> use SUPER::default_values()
-> use SUPER::help*() for info

-> write ->info help for metabricky::brick class

-> core::context: to remove check for internal variable gathering: no reason we cannot read a variable ...

-> rename remote::ssh2 to remote::ssh and rename Commands to match Net::SSH2 module
-> remote::ssh, check for exit_status when exec()

-> add <brick> in help command menu

-> all shell commands writes $_, $!, $? and $@ (including !, which is an alias)
=> version() does not comply, check every shell command
-> $_ is a string, @_ is strings splitted by "\n"
=> example: !w returns result in $_, and lines in @_
=> %_ => line numbered avec arrayref for each word

-> decide which Brick will be in main repository and which ones are private

-> make shell::meby Brick to depend on the fewest module as possible

-> add repository capacity
=> example: main::system::os, obssi::remote::serenade
=> force repository main?
=> Done, to test

-> cleanup for shell::meby  ps_* functions


### Future:
-> update() function to autoupdate
-> use page() and pager_internal() from Term::Shell
-> shell::meby: require_bricks { 'core::context' => 1 }

Bricks API: See remote::ssh2
-> require_arg() to check for a method invocation
-> require_called_first() or require_commands() to check for a previous method to be called first

Wwwutil:
-> Interrogates Hurricane Electric stuff: http://bgp.he.net/ip/130.193.27.21



### BRICKS TODO
- Heartbleed
- Zmap
- SSL Capable NetCat
- /usr/ports/net/GeoIP
- system::os: version, name, ...
- string::grep
- string::less
- file::grep
- file::less


### DOC/PRES

Name:
-> Metabricky (formerly Plashy: Perl Awesome|Audit|Attack|All-in-one Shell (Yeaaahh))
-> y: Why the Y? Yeaaaah

Rationales:
-> Tired of writing again and again some Perl scripts to do same things (where did I put this one?)
-> Tired of using different programs with different syntax
-> Tired of being lost when using Windows

Metabricky:
-> takes the best from MetaSploit CLI, Scapy ideas, and UNIX Shells.
-> Bind them in the darkness.

Metabricky - knowledge is in your head, detail is in the code
Metabricky - There is a Brick for that.
> Brain has knowledge, code has details.

Move everything to a Brick. Even ls, save, ..., cd ...
-> The software in itself is built using Bricks ...

Name:
MetaBricks?
MetaBricko?
MecaBrick?
> metabricky/meby
MetaBricko?
MetaScapy? MSP/MSY
Bricko
Bricko Depo

Design rules:
1. Only shell `run' and `get' commands can overwrite $_
=> all shell `run' and `get' commands writes $_, $? and $@ (including !, which is an alias)
2. Must be quick and easy to develop bricks
3. Must be quick and easy to USE bricks
4. Do simple functions
5. One or two args at most for a brick command, other stuff in `set' attributes
6. Everything is a brick, like everything is a file in UNIX
7. Performance is not the goal
8. Return USEFUL things from brick EVERY commands
9. Reuse CPAN modules as much as possible
10. Run command once, analyze at will
11. Commands should be non-blocking
12. Commands to return only base scalars (scalar, hashref, arrayref)

-> Within meby Shell, bricks do not print anything by default, except if shell::meby echo is set to true.
=> $_ is written with the result.

Developer rules:
- in Context::call or ::do, die() will be catched.
=> Bricks do not need access to $log.

Usage rules:
1. Three kind of command lines:
- Perl line
- Metabricky shell line
- External command

Vocabulary:
- The Shell has builtins (load, set, run)
- The Shell loads Bricks
- You enter Words on shell CLI (run core::context get, 3 words)
- meby is the Metabricky shell
- A Brick has Commands (not methods)
- A Brick has Attributes (you can set using `set' builtin)
- A Brick Command may have Arguments
- A Brick is attached to a Category
- A Brick has a Category
- A Brick may have a Repository
- Brickification: process of turning a process/software into a Meby Brick
=> Rename to use that in all code
- Meby shell can execute Code (Perl code)

Doc:
- core::context Brick autoloads core::global Brick
-> core::* bricks are always loaded and available in ->bricks->{$brick}

### FURTURE WORK

staticperl, standalone Perl with libc:
http://search.cpan.org/~mlehmann/App-Staticperl-1.43/

Take stuff from pirl:
pirl: http://cpansearch.perl.org/src/RSAVAGE/Shell-Perl-0.0023/lib/Shell/Perl.pm
ipirl: https://code.google.com/p/iperl/

How to launch a process in foreground and move it to background:
IPC::Run
IPC::Run IPC::ChildSafe Proc::Simple Proc::Reliable Proc::Fork
IO::Pipe
IPC::Run::Proc
IPC::Exe
Proc::SafeExec
Forks::Super
Spawn::Safe

shell functions:
export VAR value => $ENV{VAR} = value
unset VAR => undef $ENV{VAR}
=> completion on ENV variables
set $? and $! to indicate error and print error string

write/save: writes $_ content to a file (set out 'file.txt')
set global input $_  # default
set global ouput $_  # default
=> input and ouput may also be bricks (future work)

Proc::Simple:
=> launch cmd as background jobs (&)
=> launch system commands as background jobs

Makes use of modules:
File::Spec (path manipulation)
File::Dirname
ExtUtils::Command (shell builtins)
Env::PS1
Text::Balanced
Proc::SafePipe (http://search.cpan.org/~rosch/Proc-SafePipe-0.01/SafePipe.pm)
File::Tools
=> ls, cd, cat, df, ...
Term::ShellKit::Commands
=> reload, load, show methods/functions of a module

Gather available methods/functions:
use Metabricky::Brick::Core::Global;

--8<--
my $pkg = "Metabricky::Brick::Core::Global";
no strict 'refs';
my @r = keys %{ $pkg . "::" };
use Data::Dumper;
print Dumper(\@r);
--8<--
